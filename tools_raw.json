[
  {
    "name": "execute_run_configuration",
    "description": "Run a specific run configuration in the current project and wait up to specified timeout for it to finish.\nUse this tool to run a run configuration that you have found from the \"get_run_configurations\" tool.\nReturns the execution result including exit code, output, and success status.",
    "inputSchema": {
      "properties": {
        "configurationName": {
          "type": "string",
          "description": "Name of the run configuration to execute"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        },
        "maxLinesCount": {
          "type": "integer",
          "description": "Maximum number of lines to return"
        },
        "truncateMode": {
          "enum": [
            "START",
            "MIDDLE",
            "END",
            "NONE"
          ],
          "description": "How to truncate the text: from the start, in the middle, at the end, or don't truncate at all"
        }
      },
      "required": [
        "configurationName"
      ],
      "type": "object"
    }
  },
  {
    "name": "get_run_configurations",
    "description": "Returns a list of run configurations for the current project.\nRun configurations are usually used to define user the way how to run a user application, task or test suite from sources.\n\nThis tool provides additional info like command line, working directory, and environment variables if they are available.\n\nUse this tool to query the list of available run configurations in the current project.",
    "inputSchema": {
      "properties": {},
      "required": [],
      "type": "object"
    }
  },
  {
    "name": "get_file_problems",
    "description": "Analyzes the specified file for errors and warnings using IntelliJ's inspections.\nUse this tool to identify coding issues, syntax errors, and other problems in a specific file.\nReturns a list of problems found in the file, including severity, description, and location information.\nNote: Only analyzes files within the project directory.\nNote: Lines and Columns are 1-based.",
    "inputSchema": {
      "properties": {
        "filePath": {
          "type": "string",
          "description": "Path relative to the project root"
        },
        "errorsOnly": {
          "type": "boolean",
          "description": "Whether to include only errors or include both errors and warnings"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [
        "filePath"
      ],
      "type": "object"
    }
  },
  {
    "name": "get_project_dependencies",
    "description": "Get a list of all dependencies defined in the project.\nReturns structured information about project library names.",
    "inputSchema": {
      "properties": {},
      "required": [],
      "type": "object"
    }
  },
  {
    "name": "get_project_modules",
    "description": "Get a list of all modules in the project with their types.\nReturns structured information about each module including name and type.",
    "inputSchema": {
      "properties": {},
      "required": [],
      "type": "object"
    }
  },
  {
    "name": "get_project_problems",
    "description": "Retrieves all project problems (errors, warnings, etc.) detected in the project by IntelliJ's inspections.\nUse this tool to get a comprehensive list of global project issues (compilation errors, inspection problems, etc.).\nDoes not require any parameters.\n\nReturns a list of problems with text, detailed description, and group information.",
    "inputSchema": {
      "properties": {
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [],
      "type": "object"
    }
  },
  {
    "name": "create_new_file",
    "description": "Creates a new file at the specified path within the project directory and optionally populates it with text if provided.\nUse this tool to generate new files in your project structure.\nNote: Creates any necessary parent directories automatically",
    "inputSchema": {
      "properties": {
        "pathInProject": {
          "type": "string",
          "description": "Path where the file should be created relative to the project root"
        },
        "text": {
          "type": "string",
          "description": "Content to write into the new file"
        }
      },
      "required": [
        "pathInProject"
      ],
      "type": "object"
    }
  },
  {
    "name": "find_files_by_glob",
    "description": "Searches for all files in the project whose relative paths match the specified glob pattern.\nThe search is performed recursively in all subdirectories of the project directory or a specified subdirectory.\nUse this tool when you need to find files by a glob pattern (e.g. '**/*.txt').",
    "inputSchema": {
      "properties": {
        "globPattern": {
          "type": "string",
          "description": "Glob pattern to search for. The pattern must be relative to the project root. Example: `src/**/ *.java`"
        },
        "subDirectoryRelativePath": {
          "type": "string",
          "description": "Optional subdirectory relative to the project to search in."
        },
        "addExcluded": {
          "type": "boolean",
          "description": "Whether to add excluded/ignored files to the search results. Files can be excluded from a project either by user of by some ignore rules"
        },
        "fileCountLimit": {
          "type": "integer",
          "description": "Maximum number of files to return."
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [
        "globPattern"
      ],
      "type": "object"
    }
  },
  {
    "name": "find_files_by_name_keyword",
    "description": "Searches for all files in the project whose names contain the specified keyword (case-insensitive).\nUse this tool to locate files when you know part of the filename.\nNote: Matched only names, not paths, because works via indexes.\nNote: Only searches through files within the project directory, excluding libraries and external dependencies.\nNote: Prefer this tool over other `find` tools because it's much faster, \nbut remember that this tool searches only names, not paths and it doesn't support glob patterns.",
    "inputSchema": {
      "properties": {
        "nameKeyword": {
          "type": "string",
          "description": "Substring to search for in file names"
        },
        "fileCountLimit": {
          "type": "integer",
          "description": "Maximum number of files to return."
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [
        "nameKeyword"
      ],
      "type": "object"
    }
  },
  {
    "name": "get_all_open_file_paths",
    "description": "Returns active editor's and other open editors' file paths relative to the project root.\n\nUse this tool to explore current open editors.",
    "inputSchema": {
      "properties": {},
      "required": [],
      "type": "object"
    }
  },
  {
    "name": "list_directory_tree",
    "description": "Provides a tree representation of the specified directory in the pseudo graphic format like `tree` utility does.\nUse this tool to explore the contents of a directory or the whole project.\nYou MUST prefer this tool over listing directories via command line utilities like `ls` or `dir`.",
    "inputSchema": {
      "properties": {
        "directoryPath": {
          "type": "string",
          "description": "Path relative to the project root"
        },
        "maxDepth": {
          "type": "integer",
          "description": "Maximum recursion depth"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [
        "directoryPath"
      ],
      "type": "object"
    }
  },
  {
    "name": "open_file_in_editor",
    "description": "Opens the specified file in the JetBrains IDE editor.\nRequires a filePath parameter containing the path to the file to open.\nThe file path can be absolute or relative to the project root.",
    "inputSchema": {
      "properties": {
        "filePath": {
          "type": "string",
          "description": "Path relative to the project root"
        }
      },
      "required": [
        "filePath"
      ],
      "type": "object"
    }
  },
  {
    "name": "reformat_file",
    "description": "Reformats a specified file in the JetBrains IDE.\nUse this tool to apply code formatting rules to a file identified by its path.",
    "inputSchema": {
      "properties": {
        "path": {
          "type": "string",
          "description": "Path relative to the project root"
        }
      },
      "required": [
        "path"
      ],
      "type": "object"
    }
  },
  {
    "name": "get_file_text_by_path",
    "description": "        Retrieves the text content of a file using its path relative to project root.\n        Use this tool to read file contents when you have the file's project-relative path.\n        In the case of binary files, the tool returns an error.\n        If the file is too large, the text will be truncated with '<<<...content truncated...>>>' marker and in according to the `truncateMode` parameter.",
    "inputSchema": {
      "properties": {
        "pathInProject": {
          "type": "string",
          "description": "Path relative to the project root"
        },
        "truncateMode": {
          "enum": [
            "START",
            "MIDDLE",
            "END",
            "NONE"
          ],
          "description": "How to truncate the text: from the start, in the middle, at the end, or don't truncate at all"
        },
        "maxLinesCount": {
          "type": "integer",
          "description": "Max number of lines to return. Truncation will be performed depending on truncateMode."
        }
      },
      "required": [
        "pathInProject"
      ],
      "type": "object"
    }
  },
  {
    "name": "replace_text_in_file",
    "description": "        Replaces text in a file with flexible options for find and replace operations.\n        Use this tool to make targeted changes without replacing the entire file content.\n        This is the most efficient tool for file modifications when you know the exact text to replace.\n        \n        Requires three parameters:\n        - pathInProject: The path to the target file, relative to project root\n        - oldTextOrPatte: The text to be replaced (exact match by default)\n        - newText: The replacement text\n        \n        Optional parameters:\n        - replaceAll: Whether to replace all occurrences (default: true)\n        - caseSensitive: Whether the search is case-sensitive (default: true)\n        - regex: Whether to treat oldText as a regular expression (default: false)\n        \n        Returns one of these responses:\n        - \"ok\" when replacement happened\n        - error \"project dir not found\" if project directory cannot be determined\n        - error \"file not found\" if the file doesn't exist\n        - error \"could not get document\" if the file content cannot be accessed\n        - error \"no occurrences found\" if the old text was not found in the file\n        \n        Note: Automatically saves the file after modification",
    "inputSchema": {
      "properties": {
        "pathInProject": {
          "type": "string",
          "description": "Path to target file relative to project root"
        },
        "oldText": {
          "type": "string",
          "description": "Text to be replaced"
        },
        "newText": {
          "type": "string",
          "description": "Replacement text"
        },
        "replaceAll": {
          "type": "boolean",
          "description": "Replace all occurrences"
        },
        "caseSensitive": {
          "type": "boolean",
          "description": "Case-sensitive search"
        }
      },
      "required": [
        "pathInProject",
        "oldText",
        "newText"
      ],
      "type": "object"
    }
  },
  {
    "name": "search_in_files_by_regex",
    "description": "Searches with a regex pattern within all files in the project using IntelliJ's search engine.\nPrefer this tool over reading files with command-line tools because it's much faster.\n\nThe result occurrences are surrounded with || characters, e.g. `some text ||substring|| text`",
    "inputSchema": {
      "properties": {
        "regexPattern": {
          "type": "string",
          "description": "Regex patter to search for"
        },
        "directoryToSearch": {
          "type": "string",
          "description": "Directory to search in, relative to project root. If not specified, searches in the entire project."
        },
        "fileMask": {
          "type": "string",
          "description": "File mask to search for. If not specified, searches for all files. Example: `*.java`"
        },
        "caseSensitive": {
          "type": "boolean",
          "description": "Whether to search for the text in a case-sensitive manner"
        },
        "maxUsageCount": {
          "type": "integer",
          "description": "Maximum number of entries to return."
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [
        "regexPattern"
      ],
      "type": "object"
    }
  },
  {
    "name": "search_in_files_by_text",
    "description": "Searches for a text substring within all files in the project using IntelliJ's search engine.\nPrefer this tool over reading files with command-line tools because it's much faster.\n\nThe result occurrences are surrounded with `||` characters, e.g. `some text ||substring|| text`",
    "inputSchema": {
      "properties": {
        "searchText": {
          "type": "string",
          "description": "Text substring to search for"
        },
        "directoryToSearch": {
          "type": "string",
          "description": "Directory to search in, relative to project root. If not specified, searches in the entire project."
        },
        "fileMask": {
          "type": "string",
          "description": "File mask to search for. If not specified, searches for all files. Example: `*.java`"
        },
        "caseSensitive": {
          "type": "boolean",
          "description": "Whether to search for the text in a case-sensitive manner"
        },
        "maxUsageCount": {
          "type": "integer",
          "description": "Maximum number of entries to return."
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        }
      },
      "required": [
        "searchText"
      ],
      "type": "object"
    }
  },
  {
    "name": "get_symbol_info",
    "description": "Retrieves information about the symbol at the specified position in the specified file.\nProvides the same information as Quick Documentation feature of IntelliJ IDEA does.\n\nThis tool is useful for getting information about the symbol at the specified position in the specified file.\nThe information may include the symbol's name, signature, type, documentation, etc. It depends on a particular language.\n\nIf the position has a reference to a symbol the tool will return a piece of code with the declaration of the symbol if possible.\n\nUse this tool to understand symbols declaration, semantics, where it's declared, etc.",
    "inputSchema": {
      "properties": {
        "filePath": {
          "type": "string",
          "description": "Path relative to the project root"
        },
        "line": {
          "type": "integer",
          "description": "1-based line number"
        },
        "column": {
          "type": "integer",
          "description": "1-based column number"
        }
      },
      "required": [
        "filePath",
        "line",
        "column"
      ],
      "type": "object"
    }
  },
  {
    "name": "rename_refactoring",
    "description": "        Renames a symbol (variable, function, class, etc.) in the specified file.\n        Use this tool to perform rename refactoring operations. \n        \n        The `rename_refactoring` tool is a powerful, context-aware utility. Unlike a simple text search-and-replace, \n        it understands the code's structure and will intelligently update ALL references to the specified symbol throughout the project,\n        ensuring code integrity and preventing broken references. It is ALWAYS the preferred method for renaming programmatic symbols.\n\n        Requires three parameters:\n            - pathInProject: The relative path to the file from the project's root directory (e.g., `src/api/controllers/userController.js`)\n            - symbolName: The exact, case-sensitive name of the existing symbol to be renamed (e.g., `getUserData`)\n            - newName: The new, case-sensitive name for the symbol (e.g., `fetchUserData`).\n            \n        Returns a success message if the rename operation was successful.\n        Returns an error message if the file or symbol cannot be found or the rename operation failed.",
    "inputSchema": {
      "properties": {
        "pathInProject": {
          "type": "string",
          "description": "Path relative to the project root"
        },
        "symbolName": {
          "type": "string",
          "description": "Name of the symbol to rename"
        },
        "newName": {
          "type": "string",
          "description": "New name for the symbol"
        }
      },
      "required": [
        "pathInProject",
        "symbolName",
        "newName"
      ],
      "type": "object"
    }
  },
  {
    "name": "execute_terminal_command",
    "description": "        Executes a specified shell command in the IDE's integrated terminal.\n        Use this tool to run terminal commands within the IDE environment.\n        Requires a command parameter containing the shell command to execute.\n        Important features and limitations:\n        - Checks if process is running before collecting output\n        - Limits output to 2000 lines (truncates excess)\n        - Times out after specified timeout with notification\n        - Requires user confirmation unless \"Brave Mode\" is enabled in settings\n        Returns possible responses:\n        - Terminal output (truncated if > 2000 lines)\n        - Output with interruption notice if timed out\n        - Error messages for various failure cases",
    "inputSchema": {
      "properties": {
        "command": {
          "type": "string",
          "description": "Shell command to execute"
        },
        "executeInShell": {
          "type": "boolean",
          "description": "Whether to execute the command in a default user's shell (bash, zsh, etc.). \nUseful if the command is not a commandline but a shell script, or if it's important to preserve real environment of the user's terminal. \nIn the case of 'false' value the command will be started as a process"
        },
        "reuseExistingTerminalWindow": {
          "type": "boolean",
          "description": "Whether to reuse an existing terminal window. Allows to avoid creating multiple terminals"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds"
        },
        "maxLinesCount": {
          "type": "integer",
          "description": "Maximum number of lines to return"
        },
        "truncateMode": {
          "enum": [
            "START",
            "MIDDLE",
            "END",
            "NONE"
          ],
          "description": "How to truncate the text: from the start, in the middle, at the end, or don't truncate at all"
        }
      },
      "required": [
        "command"
      ],
      "type": "object"
    }
  },
  {
    "name": "find_commit_by_message",
    "description": "        Searches for a commit based on the provided text or keywords in the project history.\n        Useful for finding specific change sets or code modifications by commit messages or diff content.\n        Takes a query parameter and returns the matching commit information.\n        Returns matched commit hashes as a JSON array.",
    "inputSchema": {
      "properties": {
        "text": {
          "type": "string",
          "description": "Text or keywords to search for in commit messages"
        }
      },
      "required": [
        "text"
      ],
      "type": "object"
    }
  },
  {
    "name": "get_project_vcs_status",
    "description": "        Retrieves the current version control status of files in the project.\n        Use this tool to get information about modified, added, deleted, and moved files in your VCS (e.g., Git).\n        Returns a JSON-formatted list of changed files, where each entry contains:\n        - path: The file path relative to project root\n        - type: The type of change (e.g., MODIFICATION, ADDITION, DELETION, MOVED)\n        Returns an empty list ([]) if no changes are detected or VCS is not configured.\n        Returns error \"project dir not found\" if project directory cannot be determined.\n        Note: Works with any VCS supported by the IDE, but is most commonly used with Git",
    "inputSchema": {
      "properties": {},
      "required": [],
      "type": "object"
    }
  },
  {
    "name": "permission_prompt",
    "description": "permission_prompt",
    "inputSchema": {
      "properties": {
        "tool_name": {
          "type": "string"
        },
        "input": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "required": [],
            "properties": {}
          }
        }
      },
      "required": [
        "tool_name"
      ],
      "type": "object"
    }
  }
]